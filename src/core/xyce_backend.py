from __future__ import annotations
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List
import re

from .simulator_backend import ISpiceBackend
from .spice_runner import SpiceError   # Reuse your existing error type


class XyceBackend(ISpiceBackend):
    """
    Xyce backend.

    Xyce invocation:
        Xyce <netlist>

    Output:
        <netlist>.prn       (AC/DC/tran results)
        <netlist>.NOISE.prn (noise results)

    Notes:
    - This backend returns the same dictionary structure as NgSpiceBackend.
    - That means your optimization and analysis code does not need to change.
    """

    name = "xyce"

    # ------------------------------------------------------------------
    # Utility: run Xyce and return the output .prn text
    # ------------------------------------------------------------------
    def _run_xyce_and_read_prn(self, netlist: str) -> Path:
        import shutil
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            net_path = tmpdir / "circuit.cir"
            net_path.write_text(netlist, encoding="utf-8")

            # Run Xyce inside tmpdir
            result = subprocess.run(
                ["Xyce", str(net_path.name)],
                cwd=str(tmpdir),
                capture_output=True,
                text=True,
            )

            # Find any *.prn generated by Xyce
            prn_candidates = list(tmpdir.glob("*.prn"))

            if not prn_candidates:
                raise SpiceError(
                    "Xyce did not generate .prn output.\n"
                    f"STDOUT:\n{result.stdout}\n\n"
                    f"STDERR:\n{result.stderr}"
                )

            # Pick the first *.prn file (there should be exactly one)
            prn_source = prn_candidates[0]

            # Copy OUTSIDE the temp directory so it persists after cleanup
            prn_dest = Path(tempfile.mkstemp(suffix=".prn")[1])
            shutil.copyfile(prn_source, prn_dest)

            return prn_dest





    # ------------------------------------------------------------------
    # AC gain (single frequency)
    # ------------------------------------------------------------------
    def run_ac_gain(self, netlist: str) -> Dict[str, float]:
        prn = self._run_xyce_and_read_prn(netlist)
        text = prn.read_text()

        lines = [l for l in text.splitlines() if l.strip()]

        # Xyce .prn lines look like:
        #  Index   FREQ    VM(VOUT)    VM(VIN)
        numeric = []
        for line in lines:
            parts = line.split()
            try:
                # Expect: idx freq vout vin
                floats = list(map(float, parts[:4]))
                numeric.append(floats)
            except:
                continue

        if not numeric:
            raise SpiceError("Could not parse Xyce AC gain output.")

        _, freq, vout, vin = numeric[-1]

        if vin == 0:
            raise SpiceError("VIN is zero in Xyce output.")

        gain = vout / vin
        import math
        gain_db = 20 * math.log10(gain)

        return {
            "gain_db": gain_db,
            "vm_vout": vout,
            "vm_vin": vin,
        }

    # ------------------------------------------------------------------
    # AC sweep
    # ------------------------------------------------------------------
    def run_ac_sweep(self, netlist: str) -> Dict[str, List[float]]:
        prn = self._run_xyce_and_read_prn(netlist)
        text = prn.read_text()

        freq = []
        vout = []
        vin = []

        for line in text.splitlines():
            parts = line.split()
            if len(parts) < 4:
                continue
            try:
                _idx, f, vo, vi = map(float, parts[:4])
                freq.append(f)
                vout.append(vo)
                vin.append(vi)
            except:
                continue

        if not freq:
            raise SpiceError("Could not parse Xyce AC sweep results.")

        import math
        gain_db = [20 * math.log10(vo) for vo in vout]

        return {
            "freq_hz": freq,
            "vm_vout": vout,
            "vm_vin": vin,
            "gain_db": gain_db,
        }

    # ------------------------------------------------------------------
    # Noise analysis
    # ------------------------------------------------------------------
    def run_noise_sweep(self, netlist: str) -> Dict[str, float | List[float]]:
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            net_path = tmpdir / "noise.cir"
            net_path.write_text(netlist, encoding="utf-8")

            # Run Xyce in tmpdir
            subprocess.run(
                ["Xyce", str(net_path.name)],
                cwd=str(tmpdir),
                capture_output=True,
                text=True,
            )

            noise_prn = tmpdir / (net_path.name + ".NOISE.prn")
            if not noise_prn.exists():
                noise_prn = tmpdir / "noise.NOISE.prn"
            if not noise_prn.exists():
                noise_prn = net_path.with_suffix(".NOISE.prn")  # last fallback

            if not noise_prn.exists():
                raise SpiceError("Xyce did not generate NOISE.prn output")

            text = noise_prn.read_text()

            freq = []
            onoise = []
            inoise = []

            for line in text.splitlines():
                parts = line.split()
                if len(parts) < 4:
                    continue
                try:
                    _idx, f, ono, ino = map(float, parts[:4])
                    freq.append(f)
                    onoise.append(ono)
                    inoise.append(ino)
                except:
                    continue

            if not freq:
                raise SpiceError("Could not parse Xyce noise results.")

            return {
                "freq_hz": freq,
                "onoise_total": onoise,
                "inoise_total": inoise,
                "total_onoise_rms": onoise[-1],
                "total_inoise_rms": inoise[-1],
            }
